/// This machine exercises all vertex types, with and without data.
///
/**<div><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: Example Pages: 1 -->
<svg width="617pt" height="188pt"
 viewBox="0.00 0.00 616.63 188.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 184)">
<title>Example</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-184 612.63,-184 612.63,4 -4,4"/>
<!-- BeautifulBridge -->
<g id="node1" class="node">
<title>BeautifulBridge</title>
<ellipse fill="none" stroke="black" cx="84.49" cy="-90" rx="84.49" ry="18"/>
<text text-anchor="middle" x="84.49" y="-86.3" font-family="Times,serif" font-size="14.00">BeautifulBridge</text>
</g>
<!-- Tombstone -->
<g id="node7" class="node">
<title>Tombstone</title>
<ellipse fill="none" stroke="black" cx="70.49" cy="-18" rx="61.99" ry="18"/>
<text text-anchor="middle" x="70.49" y="-14.3" font-family="Times,serif" font-size="14.00">Tombstone</text>
</g>
<!-- BeautifulBridge&#45;&gt;Tombstone -->
<g id="edge1" class="edge">
<title>BeautifulBridge&#45;&gt;Tombstone</title>
<path fill="none" stroke="black" d="M81.03,-71.7C79.49,-63.98 77.63,-54.71 75.91,-46.11"/>
<polygon fill="black" stroke="black" points="79.31,-45.22 73.91,-36.1 72.44,-46.6 79.31,-45.22"/>
</g>
<!-- UnmarkedGrave -->
<g id="node8" class="node">
<title>UnmarkedGrave</title>
<ellipse fill="none" stroke="black" cx="237.49" cy="-18" rx="87.18" ry="18"/>
<text text-anchor="middle" x="237.49" y="-14.3" font-family="Times,serif" font-size="14.00">UnmarkedGrave</text>
</g>
<!-- BeautifulBridge&#45;&gt;UnmarkedGrave -->
<g id="edge2" class="edge">
<title>BeautifulBridge&#45;&gt;UnmarkedGrave</title>
<path fill="none" stroke="black" d="M118.45,-73.46C140.75,-63.26 170.14,-49.82 194.13,-38.84"/>
<polygon fill="black" stroke="black" points="195.73,-41.96 203.37,-34.61 192.82,-35.59 195.73,-41.96"/>
</g>
<!-- DesertIsland -->
<g id="node2" class="node">
<title>DesertIsland</title>
<ellipse fill="none" stroke="black" cx="350.49" cy="-162" rx="70.39" ry="18"/>
<text text-anchor="middle" x="350.49" y="-158.3" font-family="Times,serif" font-size="14.00">DesertIsland</text>
</g>
<!-- Fountain -->
<g id="node3" class="node">
<title>Fountain</title>
<ellipse fill="none" stroke="black" cx="96.49" cy="-162" rx="51.99" ry="18"/>
<text text-anchor="middle" x="96.49" y="-158.3" font-family="Times,serif" font-size="14.00">Fountain</text>
</g>
<!-- Fountain&#45;&gt;BeautifulBridge -->
<g id="edge3" class="edge">
<title>Fountain&#45;&gt;BeautifulBridge</title>
<path fill="none" stroke="black" d="M93.53,-143.7C92.2,-135.98 90.61,-126.71 89.14,-118.11"/>
<polygon fill="black" stroke="black" points="92.56,-117.37 87.42,-108.1 85.66,-118.55 92.56,-117.37"/>
</g>
<!-- Plank -->
<g id="node4" class="node">
<title>Plank</title>
<ellipse fill="none" stroke="black" cx="223.49" cy="-90" rx="36.29" ry="18"/>
<text text-anchor="middle" x="223.49" y="-86.3" font-family="Times,serif" font-size="14.00">Plank</text>
</g>
<!-- Fountain&#45;&gt;Plank -->
<g id="edge4" class="edge">
<title>Fountain&#45;&gt;Plank</title>
<path fill="none" stroke="black" d="M123.12,-146.33C142.88,-135.43 169.95,-120.51 190.99,-108.91"/>
<polygon fill="black" stroke="black" points="192.83,-111.9 199.9,-104 189.45,-105.77 192.83,-111.9"/>
</g>
<!-- Plank&#45;&gt;Tombstone -->
<g id="edge5" class="edge">
<title>Plank&#45;&gt;Tombstone</title>
<path fill="none" stroke="black" d="M197.54,-77.13C173.97,-66.34 138.82,-50.26 111.47,-37.75"/>
<polygon fill="black" stroke="black" points="112.7,-34.46 102.15,-33.48 109.78,-40.83 112.7,-34.46"/>
</g>
<!-- Plank&#45;&gt;UnmarkedGrave -->
<g id="edge6" class="edge">
<title>Plank&#45;&gt;UnmarkedGrave</title>
<path fill="none" stroke="black" d="M226.88,-72.05C228.42,-64.35 230.29,-55.03 232.02,-46.36"/>
<polygon fill="black" stroke="black" points="235.51,-46.77 234.04,-36.28 228.64,-45.39 235.51,-46.77"/>
</g>
<!-- PopulatedIsland -->
<g id="node5" class="node">
<title>PopulatedIsland</title>
<ellipse fill="none" stroke="black" cx="523.49" cy="-162" rx="85.29" ry="18"/>
<text text-anchor="middle" x="523.49" y="-158.3" font-family="Times,serif" font-size="14.00">PopulatedIsland</text>
</g>
<!-- Stream -->
<g id="node6" class="node">
<title>Stream</title>
<ellipse fill="none" stroke="black" cx="217.49" cy="-162" rx="44.69" ry="18"/>
<text text-anchor="middle" x="217.49" y="-158.3" font-family="Times,serif" font-size="14.00">Stream</text>
</g>
<!-- Stream&#45;&gt;BeautifulBridge -->
<g id="edge7" class="edge">
<title>Stream&#45;&gt;BeautifulBridge</title>
<path fill="none" stroke="black" d="M191.22,-147.17C172.01,-137.06 145.62,-123.17 123.9,-111.74"/>
<polygon fill="black" stroke="black" points="125.38,-108.57 114.9,-107.01 122.12,-114.76 125.38,-108.57"/>
</g>
<!-- Stream&#45;&gt;Plank -->
<g id="edge8" class="edge">
<title>Stream&#45;&gt;Plank</title>
<path fill="none" stroke="black" d="M218.98,-143.7C219.64,-135.98 220.43,-126.71 221.17,-118.11"/>
<polygon fill="black" stroke="black" points="224.66,-118.37 222.03,-108.1 217.69,-117.77 224.66,-118.37"/>
</g>
</g>
</svg>
</div>*/
pub mod example {
    /// This machine exercises all vertex types, with and without data.
    #[derive(Clone, Debug)]
    pub struct Example {
        state: State,
    }
    impl Example {
        /// Create a new state machine
        pub fn new(initial: State) -> Self {
            Self { state: initial }
        }
        /// Get a reference to the current state of the state machine
        pub fn state(&self) -> &State {
            &self.state
        }
        /// Get a mutable reference to the current state of the state machine
        pub fn state_mut(&mut self) -> &mut State {
            &mut self.state
        }
        /// Transition the state machine
        #[must_use = "The state must be inspected and transitioned through the returned enum"]
        pub fn entry(&mut self) -> Entry {
            match &mut self.state {
                State::BeautifulBridge { .. } => {
                    Entry::BeautifulBridge(BeautifulBridge {
                        inner: &mut self.state,
                    })
                }
                State::DesertIsland => Entry::DesertIsland,
                State::Fountain { .. } => {
                    Entry::Fountain(Fountain { inner: &mut self.state })
                }
                State::Plank { .. } => Entry::Plank(Plank { inner: &mut self.state }),
                State::PopulatedIsland(_) => {
                    match &mut self.state {
                        State::PopulatedIsland(data) => Entry::PopulatedIsland(data),
                        _ => {
                            ::core::unreachable!(
                                "state cannot change underneath us while we hold a mutable reference"
                            )
                        }
                    }
                }
                State::Stream { .. } => Entry::Stream(Stream { inner: &mut self.state }),
                State::Tombstone(_) => {
                    match &mut self.state {
                        State::Tombstone(data) => Entry::Tombstone(data),
                        _ => {
                            ::core::unreachable!(
                                "state cannot change underneath us while we hold a mutable reference"
                            )
                        }
                    }
                }
                State::UnmarkedGrave => Entry::UnmarkedGrave,
            }
        }
    }
    /// This machine exercises all vertex types, with and without data.
    #[derive(Clone, Debug)]
    pub enum State {
        /// A vertex with nonzero indegree and outdegree, with associated data
        ///
        ///This node is reachable from the following states:
        ///- [`State::Fountain`]
        ///- [`State::Stream`]
        ///
        ///This node can reach the following states:
        ///- [`State::Tombstone`]
        ///- [`State::UnmarkedGrave`]
        BeautifulBridge(Vec<u8>),
        /// An isolated vertex with no data
        DesertIsland,
        /// A source with data
        ///
        ///This node can reach the following states:
        ///- [`State::BeautifulBridge`]
        ///- [`State::Plank`]
        Fountain(std::net::IpAddr),
        /// A vertex with nonzero indegree and outdegree, with no data
        ///
        ///This node is reachable from the following states:
        ///- [`State::Fountain`]
        ///- [`State::Stream`]
        ///
        ///This node can reach the following states:
        ///- [`State::Tombstone`]
        ///- [`State::UnmarkedGrave`]
        Plank,
        /// An isolated vertex with associated data
        PopulatedIsland(String),
        /// A source with no data
        ///
        ///This node can reach the following states:
        ///- [`State::BeautifulBridge`]
        ///- [`State::Plank`]
        Stream,
        /// A sink with data
        ///
        ///This node is reachable from the following states:
        ///- [`State::BeautifulBridge`]
        ///- [`State::Plank`]
        Tombstone(char),
        /// A sink with no data
        ///
        ///This node is reachable from the following states:
        ///- [`State::BeautifulBridge`]
        ///- [`State::Plank`]
        UnmarkedGrave,
    }
    /// Access to the current state with valid transitions for the state machine.
    ///
    ///Created from [`Example::entry`].
    pub enum Entry<'a> {
        /// A vertex with nonzero indegree and outdegree, with associated data
        ///
        ///This node is reachable from the following states:
        ///- [`State::Fountain`]
        ///- [`State::Stream`]
        ///
        ///This node can reach the following states:
        ///- [`State::Tombstone`]
        ///- [`State::UnmarkedGrave`]
        BeautifulBridge(BeautifulBridge<'a>),
        /// An isolated vertex with no data
        DesertIsland,
        /// A source with data
        ///
        ///This node can reach the following states:
        ///- [`State::BeautifulBridge`]
        ///- [`State::Plank`]
        Fountain(Fountain<'a>),
        /// A vertex with nonzero indegree and outdegree, with no data
        ///
        ///This node is reachable from the following states:
        ///- [`State::Fountain`]
        ///- [`State::Stream`]
        ///
        ///This node can reach the following states:
        ///- [`State::Tombstone`]
        ///- [`State::UnmarkedGrave`]
        Plank(Plank<'a>),
        /// An isolated vertex with associated data
        PopulatedIsland(&'a mut String),
        /// A source with no data
        ///
        ///This node can reach the following states:
        ///- [`State::BeautifulBridge`]
        ///- [`State::Plank`]
        Stream(Stream<'a>),
        /// A sink with data
        ///
        ///This node is reachable from the following states:
        ///- [`State::BeautifulBridge`]
        ///- [`State::Plank`]
        Tombstone(&'a mut char),
        /// A sink with no data
        ///
        ///This node is reachable from the following states:
        ///- [`State::BeautifulBridge`]
        ///- [`State::Plank`]
        UnmarkedGrave,
    }
    /// Transition the state machine by calling the following methods:
    ///- [`BeautifulBridge::tombstone`]
    ///- [`BeautifulBridge::unmarked_grave`]
    pub struct BeautifulBridge<'a> {
        inner: &'a mut State,
    }
    /// Transition the state machine by calling the following methods:
    ///- [`Fountain::beautiful_bridge`]
    ///- [`Fountain::plank`]
    pub struct Fountain<'a> {
        inner: &'a mut State,
    }
    /// Transition the state machine by calling the following methods:
    ///- [`Plank::tombstone`]
    ///- [`Plank::unmarked_grave`]
    pub struct Plank<'a> {
        inner: &'a mut State,
    }
    /// Transition the state machine by calling the following methods:
    ///- [`Stream::beautiful_bridge`]
    ///- [`Stream::plank`]
    pub struct Stream<'a> {
        inner: &'a mut State,
    }
    impl BeautifulBridge<'_> {
        /// Get a reference to the data stored in this state
        pub fn get(&self) -> &Vec<u8> {
            match &self.inner {
                State::BeautifulBridge(data) => data,
                _ => {
                    ::core::unreachable!(
                        "this variant is only created when state is known to match, and we hold a mutable reference to state"
                    )
                }
            }
        }
        /// Get a mutable reference to the data stored in this state
        pub fn get_mut(&mut self) -> &mut Vec<u8> {
            match self.inner {
                State::BeautifulBridge(data) => data,
                _ => {
                    ::core::unreachable!(
                        "this variant is only created when state is known to match, and we hold a mutable reference to state"
                    )
                }
            }
        }
    }
    impl BeautifulBridge<'_> {
        /// This documentation is shared from `Fountain` to `BeautifulBridge` to `Tombstone`
        pub fn tombstone(self, next: char) -> Vec<u8> {
            let prev = ::core::mem::replace(self.inner, State::Tombstone(next));
            match prev {
                State::BeautifulBridge(data) => data,
                _ => {
                    ::core::unreachable!(
                        "this variant is only created when state is known to match, and we hold a mutable reference to state"
                    )
                }
            }
        }
    }
    impl BeautifulBridge<'_> {
        pub fn unmarked_grave(self) -> Vec<u8> {
            let prev = ::core::mem::replace(self.inner, State::UnmarkedGrave);
            match prev {
                State::BeautifulBridge(data) => data,
                _ => {
                    ::core::unreachable!(
                        "this variant is only created when state is known to match, and we hold a mutable reference to state"
                    )
                }
            }
        }
    }
    impl Fountain<'_> {
        /// Get a reference to the data stored in this state
        pub fn get(&self) -> &std::net::IpAddr {
            match &self.inner {
                State::Fountain(data) => data,
                _ => {
                    ::core::unreachable!(
                        "this variant is only created when state is known to match, and we hold a mutable reference to state"
                    )
                }
            }
        }
        /// Get a mutable reference to the data stored in this state
        pub fn get_mut(&mut self) -> &mut std::net::IpAddr {
            match self.inner {
                State::Fountain(data) => data,
                _ => {
                    ::core::unreachable!(
                        "this variant is only created when state is known to match, and we hold a mutable reference to state"
                    )
                }
            }
        }
    }
    impl Fountain<'_> {
        /// This documentation is shared from `Fountain` to `BeautifulBridge` to `Tombstone`
        pub fn beautiful_bridge(self, next: Vec<u8>) -> std::net::IpAddr {
            let prev = ::core::mem::replace(self.inner, State::BeautifulBridge(next));
            match prev {
                State::Fountain(data) => data,
                _ => {
                    ::core::unreachable!(
                        "this variant is only created when state is known to match, and we hold a mutable reference to state"
                    )
                }
            }
        }
    }
    impl Fountain<'_> {
        /// This is also shared among a few transitions.
        ///
        ///just on fountain to plank
        pub fn plank(self) -> std::net::IpAddr {
            let prev = ::core::mem::replace(self.inner, State::Plank);
            match prev {
                State::Fountain(data) => data,
                _ => {
                    ::core::unreachable!(
                        "this variant is only created when state is known to match, and we hold a mutable reference to state"
                    )
                }
            }
        }
    }
    impl Plank<'_> {
        ///plank transitions to tombstone
        pub fn tombstone(self, next: char) {
            let prev = ::core::mem::replace(self.inner, State::Tombstone(next));
            ::core::debug_assert!(::core::matches!(prev, State::Plank));
        }
    }
    impl Plank<'_> {
        /// This is also shared among a few transitions.
        pub fn unmarked_grave(self) {
            let prev = ::core::mem::replace(self.inner, State::UnmarkedGrave);
            ::core::debug_assert!(::core::matches!(prev, State::Plank));
        }
    }
    impl Stream<'_> {
        pub fn beautiful_bridge(self, next: Vec<u8>) {
            let prev = ::core::mem::replace(self.inner, State::BeautifulBridge(next));
            ::core::debug_assert!(::core::matches!(prev, State::Stream));
        }
    }
    impl Stream<'_> {
        ///different arrow lengths are ok
        pub fn plank(self) {
            let prev = ::core::mem::replace(self.inner, State::Plank);
            ::core::debug_assert!(::core::matches!(prev, State::Stream));
        }
    }
    impl ::core::fmt::Debug for BeautifulBridge<'_> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct(::core::stringify!(BeautifulBridge)).finish_non_exhaustive()
        }
    }
    impl ::core::fmt::Debug for Fountain<'_> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct(::core::stringify!(Fountain)).finish_non_exhaustive()
        }
    }
    impl ::core::fmt::Debug for Plank<'_> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct(::core::stringify!(Plank)).finish_non_exhaustive()
        }
    }
    impl ::core::fmt::Debug for Stream<'_> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct(::core::stringify!(Stream)).finish_non_exhaustive()
        }
    }
}
